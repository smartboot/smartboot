(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[795],{6039:(t,e,a)=>{"use strict";a.r(e),a.d(e,{data:()=>r});const r={key:"v-d9022c4a",path:"/smart-socket/chapter-3/",title:"第三章 通信协议",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[],filePathRelative:"smart-socket/chapter-3/README.md",git:{updatedTime:1614227498e3}}},4710:(t,e,a)=>{"use strict";a.r(e),a.d(e,{default:()=>d});var r=a(6252);const s=(0,r.Wm)("h1",{id:"第三章-通信协议"},[(0,r.Wm)("a",{class:"header-anchor",href:"#第三章-通信协议"},"#"),(0,r.Uk)(" 第三章 通信协议")],-1),l=(0,r.Wm)("p",null,'"协议"这个词在本文中反复提及，通信领域中的”协议“等同于人们日常所认知的协议概念，例如：保密协议，就业协议等。协议是对双方行为准则的约束，任何一方背离既定协议规则，都会导致双方的关系出现问题。现实生活的中的协议形态可能是一纸文书，又或者是双方口头达成的共识，而在通信领域中协议是双方对传输/接受数据流的编解码实现算法。',-1),c=(0,r.Wm)("p",null,[(0,r.Uk)("众所周知，数据在网络上是以字节流的形式传输（如若较真点也可以说是二进制流），而字节的定义是在所有计算机语言中定义的都是8bit。所以只要通过协议不仅可以翻译网络中数据流的业务含义，又可实现跨计算机语言的通信。从事通信开发的朋友要谨记我们要"),(0,r.Wm)("strong",null,"面向协议编程"),(0,r.Uk)("，在开发过程中遇到问题切勿再质疑是否跟对方所使用的语言有关系？而是要确定对方是否准守通信协议，自己又是否准守了通信协议。")],-1),n=(0,r.Wm)("p",null,"目前业界已经存在大量的标准协议支撑了整个互联网世界，诸如：Http，FTP，SMTP，MQTT，而私有协议更多。所谓“私有协议”指由双方自行约定编解码规则的协议，而非业界公认的通信规范。本章节我们会带着大家一起学习协议的正确处理方式，尽管编解码不是一件难事，但对于新手朋友这也并不简单。如果您对于半包、粘包的处理方式还不甚了解，不妨好好阅读本章内容，以后也请勿抛出此类问题，因为这比较”不专业“。",-1),d={render:function(t,e){return(0,r.wg)(),(0,r.j4)(r.HY,null,[s,l,c,n],64)}}}}]);