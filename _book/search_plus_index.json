{"./":{"url":"./","title":"关于smartboot","keywords":"","body":"关于smartboot 一个人的开源组织。 作品 smart-socket 仅800多行代码实现极简、易用、高性能的java AIO通信框架，也许是IM、RPC、IoT开发的最佳选择 smart-boot 基于springboot封装的微服务框架. somart-ioc Java NIO实现的smart-socket android 版通信框架 maven-mydalgen-plugin mybatis代码自动生成的Maven插件，简化sql书写，避免大量动态sql。 分享 暂无 成员 三刀 加入方式： 方式一：捐赠smartboot ￥1,000,000。 方式二： 发表smartboot任一项目文章并获得1W以上的阅读量，不限平台。 开源作者或为开源作出过贡献。 smartboot成员认可。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:26:30 "},"smart-socket-v1.4/":{"url":"smart-socket-v1.4/","title":"前言","keywords":"","body":"介绍 smart-socket是一款历史比较悠久的开源项目，可追溯的最早历史痕迹可至2015年。 直到2017年夏天它才进入大众的视野并有了点小名气，正是在那一年smart-socket完成了nio往aio的转型。 由于其极简、易用、高性能的特性吸引了一些用户的青睐，并在开源社区的助推下发展至 v1.4版。 smart-socket的定位是只做最纯粹的通信框架，只要是Java语言的通信开发需求，它都能满足你。 如今smart-socket已经广泛应用于物联网领域，用户选择它的理由基本是：稳定、上手快。 事实上掌握smart-socket并不依赖本教程，因为它简单到只有两个接口的学习成本。 考虑到有些朋友初次接触通信编程，还是需要一份使用教程辅助学习，故特地撰写了此文。 当然个人能力有限，本书中描述的内容难免会有错漏之处，还望读者朋友谅解并及时反馈至作者（zhengjunweimail@163.com）加以订正。希望读完本书后你能有所收获，祝大家阅读愉快！ Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-07-02 21:24:59 "},"smart-socket-v1.4/chapter-1/2.1-基础应用/":{"url":"smart-socket-v1.4/chapter-1/2.1-基础应用/","title":"1.1 快速上手","keywords":"","body":"快速上手 JDK1.7是采用smart-socket进行开发的最低版本要求，如果您还在用JDK1.6或者更低的版本，请先升级您的JDK。 如果您从事的是Android通信开发，可能会面临低版本系统而无法使用smart-socket的问题，为此我们专为采用NIO技术开发了Android版本通信框架smart-ioc，因其不属于本章主角故暂不多做介绍。 除了JDK，建议事先准备一款顺手的IDE，并搭建好Maven环境，会有更高的开发效率。 smart-socket并不依赖除slf4j-api之外的其他第三方jar包，所以你可以很轻松的将它集成到你的项目中，无需担心会发生jar包冲突的问题。 得益于smart-socket代码量极少的特性，你甚至可以选择直接将源码拷贝到自己的项目中，维护一个专属于你的私有版smart-socket。 不过我们更推荐的是采用maven方式引入smart-socket，这样便可享受由原作者提供后续的版本升级服务。 码云 https://gitee.com/smartboot/smart-socket GITHUB https://github.com/smartboot/smart-socket Maven org.smartboot.socket aio-core 1.4.0 2.1.1 工程搭建 ​ 本章以Maven工程为例为大家演示基于smart-socket实现socket开发，如果您已经有现成的工程仅需引入pom.xml依赖即可，否则请先建立一个项目工程。 ​ 从上图可以看到，我们在pom.xml中引入了smart-socket的核心包aio-core 1.4.0，最终工程衍生出来的依赖包仅slf4j-api。工程搭建完毕后，我们正式开始smart-socket的开发之旅。 2.1.2 协议约定 ​ 通信中所说的协议是指双方实体完成通信或服务所必须遵循的规则和约定。协议定义了数据单元使用的格式，信息单元应该包含的信息与含义，连接方式，信息发送和接收的时序，从而确保网络中数据顺利地传送到确定的地方。 ​ 此前我们也提及过数据通信过程中采用的是字节流，服务端与客户端之间传递的一系列数值具体代表什么含义？依靠的是通信双方事先约定好的协议规范，双方根据约定的协议进行消息的编码、传输、解码，就能进行可靠的消息通信。 协议的制定，需要满足三要素： 语法：约定通信的数据格式，编码，信号等级 语义：在语法的基础上传递的数据内容 定时规则：明确通信内容的时序 下面我们来定义一套简单的通信协议，并基于该协议实现服务端与客户端的信息交互。如下图所示，每个单元格表示一个Byte，整个消息由两部分组成： 消息头：固定一个byte长度 消息体：根据消息体中的数值决定消息体长度。当N等于1，消息体长度也则为1；当N等于10，消息体长度则为10。 ​ 按照上述规则，我们可以得出一个公式：消息长度=消息头长度+消息体长度，而消息体的长度取决于消息头中的数值。这就是所谓的协议，那根据这个协议，我们如何实现传输呢？ 以字符串“socket”为例，按照上述协议进行编码后的结果为： 该协议采用smart-socket可用如下算法实现解码： 标志当前buffer的postion位置； 获取本次消息的消息体长度，position递增1位； 判断当前已读的数据长度是否满足消息体长度； 出现半包，数据不完整，重置标志位，并返回null终止本次解码； buffer中包含完整的消息体内容，则进行读取，postiton=postion+增加消息体长度; 更新标志位 将已读数据转换为字符串并返回，解码成功。 public class StringProtocol implements Protocol { public String decode(ByteBuffer buffer, AioSession session) { buffer.mark(); // 1 byte length = buffer.get(); // 2 if (buffer.remaining() 同样的协议可以有不同的解析算法，不同算法的优劣各不相同。依旧以此协议为例，解析算法还能这样写： 1. 采用绝对定位的方式识别消息长度，该读取方式不会改变readBuffer的position值； 2. 判断当前readBuffer中待读取的数据长度是否满足消息体长度；不满足条件说明存在半包情况，返回null； 3. 若消息数据完整，构建用于存放数据的byte数组，通过执行readBuffer.get()设置数组长度。此get方法会对readBuffer的position作加1操作。 再次执行readBuffer.get方法，以byte数组为入参接受消息体数据，此操作也会影响readBuffer的position； 构建字符串对象，解码成功。 public class StringProtocol implements Protocol { @Override public String decode(ByteBuffer readBuffer, AioSession session) { byte length = readBuffer.get(readBuffer.position());//1 if (length+1 ​ 协议编解码是通信编程中非常重要的一个环节，如果读者朋友目前还不是特别能理解，那就谨记一件事：掌握协议编解码，通信就学会了80%，剩下的20%就是业务处理。根据作者以往的经验，很多初学者都被困扰在这个环节，一旦闯过这一关就柳暗花明了。 2.1.3 服务端 ​ 我们努力缩短大家对smart-socket的学习路径，故在接口设计上力求简洁，有助于您快速将服务搭建起来。启动步骤如下： 构造服务端对象AioQuickServer。该类的构造方法有以下几个入参： port，服务端监听端口号，客户度要请求该端口号才可连上服务端。 Protocol，协议解码类，将ByteBuffer中已读部分的byte数据还原成消息实体 MessageProcessor，消息处理器，对Protocol解析出来的消息进行业务处理 启动Server服务 public class Server { public static void main(String[] args) throws IOException { // 1 AioQuickServer server = new AioQuickServer(8080, new StringProtocol(), new MessageProcessor() { public void process(AioSession session, String msg) { System.out.println(\"接受到客户端消息:\" + msg); byte[] response = \"Hi Client!\".getBytes(); byte[] head = {(byte) response.length}; try { session.getOutputStream().write(head); session.getOutputStream().write(response); } catch (IOException e) { e.printStackTrace(); } } public void stateEvent(AioSession session, StateMachineEnum stateMachineEnum, Throwable throwable) { } }); //2 server.start(); } } ​ 上述代码中启动了端口号8080的服务端应用，当接收到客户端发送过来的数据时，服务端以StringProtocol进行协议解码，识别出客户度传递的字符串，而后将该消息转交给消息处理器MessageProcessor进行业务处理。 2.1.4 客户端 ​ 客户度的开发相较于服务端就简单很多，仅需操作一个连接会话（AioSession）即可，而服务端面向的是众多连接会话，在实际运用中还得具备并发思维与会话资源管理策略。客户端的开发步骤通常如下： 连接服务端，取得连接会话（AioSession） 发送请求消息 处理响应消息 关闭客户端 public class Client { public static void main(String[] args) throws InterruptedException, ExecutionException, IOException { AioQuickClient client = new AioQuickClient(\"127.0.0.1\", 8080, new StringProtocol(), new MessageProcessor() { public void process(AioSession session, String msg) { System.out.println(msg); } public void stateEvent(AioSession session, StateMachineEnum stateMachineEnum, Throwable throwable) { } }); AioSession session = client.start(); byte[] msgBody = \"Hello Server!\".getBytes(); byte[] msgHead = {(byte) msgBody.length}; try { session.getOutputStream().write(msgHead); session.getOutputStream().write(msgBody); session.getOutputStream().flush(); } catch (IOException e) { e.printStackTrace(); } } } 2.1.5 启动运行 ​ 完成代码的编写后我们便可先后启动服务端、客户端程序，观察通信服务的运行结果。服务端启动成功后，会在控制台打印如下信息，如启动失败请检查是否存在端口被占用的情况。 ​ 接下来我们再启动客户端程序，客户端启动成功后会直接发送一个“Hello Server!”的消息给服务端，并通过消息处理器(MessageProcessor)打印所接受到的服务端响应消息“Hi Client!”。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-07-02 21:32:47 "},"smart-socket-v1.4/chapter-1/2.2-Spring集成/":{"url":"smart-socket-v1.4/chapter-1/2.2-Spring集成/","title":"1.2 Spring集成smart-socket","keywords":"","body":"2.2 Spring集成smart-socket ​ smart-socket为我们的通信服务提供了良好的解决方案，但更多时候我们的系统工程并不仅仅只有通信，而是一系列服务类型的混合体。比如我们将一个Web工程放置于Tomcat为用户提供Http服务的同时，在后台还开放了RPC服务供第三方应用调用，而且整个工程采用的是Spring框架进行开发。此时就会涉及到smart-socket与Spring的集成问题，需要将通信服务实例交由Spring进行管理。 ​ 此处以xml配置和注解两种方式为大家介绍smart-socket于spring的集成方案，前期需要做的准备工作就是先搭建一个spring工程，并引入smart-socket依赖，pom.xml配置如下图。 2.2.1 xml配置化启动服务 ​ 通过2.1章节我们了解到smart-socket启用通信服务依赖两个关键的要素：Protocol、MessageProcessor，在spring的集成应用中我们依旧需要定义它们的实现类。接下来我们会以服务端场景为例给大家演示，如果您是要进行客户端通信服务与Spring的集成，请按同样的操作方式替换一下相应的配置即可。 定义协议类 public class StringProtocol implements Protocol { @Override public String decode(ByteBuffer readBuffer, AioSession session) { int remaining = readBuffer.remaining(); if (remaining readBuffer.remaining()) { readBuffer.reset(); return null; } byte[] b = new byte[length]; readBuffer.get(b); readBuffer.mark(); return new String(b); } } 定义处理器 public class ServerProcessor implements MessageProcessor { @Override public void process(AioSession session, String msg) { BufferOutputStream outputStream = session.getOutputStream(); byte[] bytes = msg.getBytes(); outputStream.writeInt(bytes.length); try { outputStream.write(bytes); } catch (IOException e) { e.printStackTrace(); } } @Override public void stateEvent(AioSession session, StateMachineEnum stateMachineEnum, Throwable throwable) { } } 准备工作就绪后，我们需要在application.xml配置它们的实例bean，并将其引用至AioQuickServer的bean配置。因为AioQuickServer的构造方法都是带参数的，所以配置bean的时候需要用到标签constructor-arg。 如此一来只需启动spring容器，我们的通信服务便开始运行。接下来我们来验证一下集成后的效果，如果将其配置到真正的web服务中演示过程稍显琐碎，故我们直接通过main函数来调用。 public class SpringDemo { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"application.xml\"); AioQuickServer aioQuickServer = context.getBean(\"aioQuickServer\", AioQuickServer.class); System.out.println(\"服务启动成功：\" + aioQuickServer); ((ClassPathXmlApplicationContext) context).close(); System.out.println(\"服务关闭\"); } } 执行上述代码后控制台会打印服务的启动与关闭日志，如果出现异常，请检查端口号是否被占用。 2.2.2 注解方式启动服务 如果读者习惯用注解的方式使用Spring，那我们需要对原有的代码稍加改动。Protocol和MessageProcessor实现类需要加上注解@Component。 定义协议类 @Component(\"protocol\") public class StringProtocol implements Protocol { @Override public String decode(ByteBuffer readBuffer, AioSession session) { int remaining = readBuffer.remaining(); if (remaining readBuffer.remaining()) { readBuffer.reset(); return null; } byte[] b = new byte[length]; readBuffer.get(b); readBuffer.mark(); return new String(b); } } 定义处理器 @Component(\"messageProcessor\") public class ServerProcessor implements MessageProcessor { @Override public void process(AioSession session, String msg) { BufferOutputStream outputStream = session.getOutputStream(); byte[] bytes = msg.getBytes(); outputStream.writeInt(bytes.length); try { outputStream.write(bytes); } catch (IOException e) { e.printStackTrace(); } } @Override public void stateEvent(AioSession session, StateMachineEnum stateMachineEnum, Throwable throwable) { } } 接下来我们修改application.xml配置，default-autowire=\"byName\"表示优先按bean名称注入，而注解的扫描扫描包路径为org.smartboot.example.spring。 最后我们还需要以注解的形式构造AioQuickServer对象并启动服务。 @Component public class SpringDemo { @Autowired private MessageProcessor messageProcessor; @Autowired private Protocol protocol; private AioQuickServer aioQuickServer; public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"application.xml\"); SpringDemo demo = context.getBean(\"springDemo\", SpringDemo.class); System.out.println(\"服务启动成功：\" + demo.aioQuickServer); ((ClassPathXmlApplicationContext) context).close(); System.out.println(\"服务关闭\"); } @PostConstruct public void init() { aioQuickServer = new AioQuickServer(8080, protocol, messageProcessor); try { aioQuickServer.start(); } catch (IOException e) { e.printStackTrace(); } } @PreDestroy public void destroy() { aioQuickServer.shutdown(); } } Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 21:20:08 "},"smart-socket-v1.4/chapter-1/SUMMARY.html":{"url":"smart-socket-v1.4/chapter-1/SUMMARY.html","title":"小结","keywords":"","body":"小结 本章为大家演示了smart-socket最基础的应用，可以看到该框架相较于其它知名NIO框架（具备代表性的AIO框架不多，暂且不论），开发起来的代码量和难度都是比较低的。 接下来我们会对smart-socket进行更深入的剖析，感兴趣的读者朋友可继续往下看，如果结合smart-socket的源码阅读效果更佳。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-07-02 21:58:08 "},"smart-socket-v1.4/BLANK.html":{"url":"smart-socket-v1.4/BLANK.html","title":"第二章 源码解析","keywords":"","body":"未完待续，或Star本项目后加群：830015805 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-07-02 21:45:40 "},"smart-socket-v1.4/chapter-3/":{"url":"smart-socket-v1.4/chapter-3/","title":"第三章 通信协议","keywords":"","body":"第三章 通信协议 \"协议\"这个词在本文中反复提及，通信领域中的”协议“等同于人们日常所认知的协议概念，例如：保密协议，就业协议等。协议是对双方行为准则的约束，任何一方背离既定协议规则，都会导致双方的关系出现问题。现实生活的中的协议形态可能是一纸文书，又或者是双方口头达成的共识，而在通信领域中协议是双方对传输/接受数据流的编解码实现算法。 众所周知，数据在网络上是以字节流的形式传输（如若较真点也可以说是二进制流），而字节的定义是在所有计算机语言中定义的都是8bit。所以只要通过协议不仅可以翻译网络中数据流的业务含义，又可实现跨计算机语言的通信。从事通信开发的朋友要谨记我们要面向协议编程，在开发过程中遇到问题切勿再质疑是否跟对方所使用的语言有关系？而是要确定对方是否准守通信协议，自己又是否准守了通信协议。 目前业界已经存在大量的标准协议支撑了整个互联网时间，诸如：Http，FTP，SMTP，MQTT，而私有协议更多。所谓“私有协议”指由双方自行约定编解码规则的协议，而非业界公认的通信规范。本章节我们会带着大家一起学习协议的正确处理方式，尽管编解码不是一件难事，但对于新手朋友这也并不简单。如果您对于半包、粘包的处理方式还不甚了解，不妨好好阅读本章内容，以后也请勿抛出此类问题，因为这比较”门外汉“。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-07-02 21:44:26 "},"smart-socket-v1.4/chapter-3/1-消息归类/":{"url":"smart-socket-v1.4/chapter-3/1-消息归类/","title":"3.1 消息归类","keywords":"","body":"3.1 消息归类 在正式讲解之前我们先来对常见的几种消息进行分类，方便大家理解消化。后续在工作终于遇到问题时可按照本文定义的类别寻找相应的解决方法。注意，此处讲的是“消息”，并非协议，可能有人疑惑这两者的区别。用面向对象的思想简单理解就是：协议等同于class，消息就是class实例化后的object。为了便于区分，我们将消息分类以下几种： 3.1.1 一类消息 服务端与客户端之间通信的所有消息大小都是在一定范围内的，AIOSession的readBuffer容量完全可以承载至少一个消息（前提是readBuffer的容量本身就设置了一个“合理”的数值）。这个“合理”的定义是ReadBuffer容量尽可能的满足绝大部分消息长度，且数值不会超过一定阈值。假设我们暂定readBuffer的容量阈值为1024，那么以下几种消息则属于一类消息： 所有消息长度都小于100，readBuffer设置容量为100 消息长度范围[0,512)，readBuffer容量设置为512 消息长度范围[0,1024),readBuffer容量设置为1024 那如果消息长度范围为[0,2048)呢，我们是否可以通过将readBuffer容量设置为2048来满足我们的需求？答案是否定的，如果绝大部分情况下消息大小在1024内，仅少量的消息大小在[1024,2048)区间内，扩大readBuffer容量会导致缓存空间利用率不高，这对于内存资源是一直浪费。所以存在此类情况的消息不属于“一类消息”。 3.1.2 二类消息 假设readBuffer的容量阈值依旧是1024，绝大部分消息长度都未超过该范围，但是偶尔有几个消息长度超过了1024，此为二类消息。二类消息的定义还存在一个限制条件，尽管消息长度超过了1024，但是不可超的太离谱。当我们认为一个消息因太长，导致无法完整的进行内存存储时，我们将其定义为“三类消息”。 现在先介绍一下二类消息的处理方式，譬如我们定义的readBuffer容量为512byte，这已经满足99%消息的容量需求，但可能存在1%的消息长度会超过这阈值，我们姑且将这消息长度定义为600byte。针对此类消息，在解码时需要申请一个足够容量的临时缓冲区用于存放当前消息的字节数组，这个临时缓冲区可能是个固定长度的大缓冲区，又可能是个可自动扩容的缓冲区。 或许读者朋友会问，为什么smart-socket的readBuffer不提供自动扩容缓冲区的能力？那是由于框架无法识别消息的有效性，一旦遭遇恶意攻击或者用户滥用可扩容的读缓冲区，会造成内存方面不可预知的异常情况。smart-socket在设计之初便非常重视服务的稳定性，对于用户技能水平的要求也会略高于某些同类通信框架，由此也导致smart-socket的使用体验稍显逊色。如果要在迎合用户的使用体验与服务可靠性之间做一个选择，smart-socket选择后者，毕竟技能水平的提升每个从业人员必要的坚持。 几乎绝大多数协议或者协议中某个字段约定的解析规则就两种：定长协议、特定结束符解析。接下里分别介绍两种类型的处理方式，为了方便举例，我们将缓冲区容量定义为8byte。在处理二类消息的过程中我们会引用到aio-pro提供的解码器，所以读者朋友在使用前请先在pom.xml中引入aio-pro的依赖。 org.smartboot.socket aio-pro 1.4.X 定长协议 协议格式： 字段 含义 长度 length 消息头，其值表示消息体长度 1字节 data 消息体 length值 根据上述协议，假设客户端发送的消息为：9abcdefjhi，第一位消息头”9“为byte类型，占用了1字节，后续的消息体“abcdefjhi”占用了9字节，所以服务端本次收到的消息长度为：10字节。由于读缓冲区的长度限制为8，则“9abcdefg”便填满了缓冲区，需要先将其读取完后再去读“hi”。编解码算法如下所示： public class FixedLengthProtocol implements Protocol { @Override public String decode(ByteBuffer readBuffer, AioSession session) { if (!readBuffer.hasRemaining()) { return null; } FixedLengthFrameDecoder fixedLengthFrameDecoder; if (session.getAttachment() != null) { fixedLengthFrameDecoder = session.getAttachment(); } else { byte length = readBuffer.get();//获得消息体长度 fixedLengthFrameDecoder = new FixedLengthFrameDecoder(length);//构建指定长度的临时缓冲区 session.setAttachment(fixedLengthFrameDecoder);//缓存临时缓冲区 } if (!fixedLengthFrameDecoder.decode(readBuffer)) { return null;//已读取的数据不足length，返回null } //数据读取完毕 ByteBuffer fullBuffer = fixedLengthFrameDecoder.getBuffer(); byte[] bytes = new byte[fullBuffer.remaining()]; fullBuffer.get(bytes); session.setAttachment(null);//释放临时缓冲区 return new String(bytes); } } 定长消息的处理核心在于通过FixedLengthFrameDecoder开辟一块足够容量的临时缓冲区，待读取完整的有效数据后再进行后续的解码操作。 特定结束符协议 协议格式： 字段 含义 长度 data 消息体 未知 endFlag 结束符 endFlag的字节长度 相较于定长协议，此类协议在解码结束之前都无法知晓消息的长度，直到读取到结束符标志，则此前所有已读的数据方可组成一个完整的消息或消息字段。例如按行发送的字符串数据：abc\\r\\n123\\r\\n，以\\r\\n作为结束符发送了两个消息：abc，123。 public class DelimiterProtocol implements Protocol { //结束符\\r\\n private static final byte[] DELIMITER_BYTES = new byte[]{'\\r', '\\n'}; @Override public String decode(ByteBuffer buffer, AioSession session) { DelimiterFrameDecoder delimiterFrameDecoder; if (session.getAttachment() == null) {//构造指定结束符的临时缓冲区 delimiterFrameDecoder = new DelimiterFrameDecoder(DELIMITER_BYTES, 64); session.setAttachment(delimiterFrameDecoder);//缓存解码器已应对半包情况 } else { delimiterFrameDecoder = session.getAttachment(); } //未解析到DELIMITER_BYTES则返回null if (!delimiterFrameDecoder.decode(buffer)) { return null; } //解码成功 ByteBuffer byteBuffer = delimiterFrameDecoder.getBuffer(); byte[] bytes = new byte[byteBuffer.remaining()]; byteBuffer.get(bytes); session.setAttachment(null);//释放临时缓冲区 return new String(bytes); } } 3.1.3 三类消息 此类消息的特点就是消息体非常大，已经不适合进行内存存储了。例如文件上传类的Http消息，此时完整的消息可能小则几兆，大的则以G为单位。不过本节讲解三类消息不会以Http为例，因为Http是个相对比较复杂的协议，在真实场景中可能是二类消息、三类消息的混合式解码。此处以定长协议来传输一个100MB的文件。 协议格式： 字段 含义 长度 length 消息头，其值表示消息体长度 4字节 data 消息体 length值 100MB=104857600byte，转换成4字节的内存存储如下所示，后面的”?“代表文件的字节码。在识别出文件长度后，通过AioSession.getInputStream封装流对象并返回消息对象，之后在消息处理器中再获取BigObject的流对象便可将整个文件内容读取出来。需要注意的事，一旦使用了AioSession.getInputStream接口，则当前连接的数据读取便切换为同步阻塞模式，所以在完成读取或异常之前会占用当前线程资源，但优点以极低的内存消耗实现超大消息的解析。 public class BigObject { private InputStream inputStream; public BigObject(InputStream inputStream) { this.inputStream = inputStream; } public InputStream getInputStream() { return inputStream; } } public class BigObjectProtocol implements Protocol { @Override public BigObject decode(ByteBuffer readBuffer, AioSession session) { if (readBuffer.remaining() 提问：如果通信的所有消息都固定在1MB的大小，则此类消息算哪一种？ Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-07-02 21:41:40 "},"smart-socket-v1.4/chapter-5/":{"url":"smart-socket-v1.4/chapter-5/","title":"第是章 内存池","keywords":"","body":"第四章 内存池 内存池似乎已经当下各个牛逼框架的标配，我们也专门为smart-socket度身打造了一款内存池解决方案。当然我们并不是为了盲目跟风，确实是有一些问题需要通过该项技术得以解决，并且smart-socket的内存池表现非常令人满意。在此跟大家分享一下smart-socket内存池的设计理念，但愿能与读者朋友产生共鸣。 smart-socket引入内存池设计，主要为了解决两个问题：零拷贝、对象复用。 零拷贝； 接触过Netty的朋友应该都听说过该项技术，这项技术的原理也很简单。在数据传输时，如果存储数据的ByteBuffer是堆内缓冲区对象HeapByteBuffer，则在输出时JVM会将该缓冲区的数据拷贝到堆外的直接缓冲区DirectByteBuffer再输出，该场景就存在一次内存拷贝。而如果一开始我们就将数据写入直接缓冲区DirectByteBuffer，则无需进行数据拷贝便可输出数据，这就是所谓的零拷贝，而零拷贝所带来的好处就是节省了临时内存和CPU的消耗，以下便是JVM执行数据输出的处理方式，阅读源码有助于读者朋友更深刻的理解零拷贝。 static int write(FileDescriptor var0, ByteBuffer var1, long var2, NativeDispatcher var4) throws IOException { if (var1 instanceof DirectBuffer) { return writeFromNativeBuffer(var0, var1, var2, var4); } else { int var5 = var1.position(); int var6 = var1.limit(); assert var5 0) { var1.position(var5 + var9); } var10 = var9; } finally { Util.offerFirstTemporaryDirectBuffer(var8); } return var10; } } 复用对象； 实现对象的复用一方面可以节省对象构造造成的时间成本，另一方面可以大大减少运行过程中产生的对象数，缓解GC压力。特别对于直接缓冲区DirectByteBuffer对象，不仅创建耗时长，而且因其存在于堆外内存中导致无法通过垃圾回收器释放内存，非常适合通过池化管理提升对象复用率。 4.1 设计原理 ​ smart-socket内存池的设计原理比较简单，事先在堆外内存中申请一个大的DirectByteBuffer，后续使用时通过DirectByteBuffer映射出实际所需大小的虚拟Buffer于堆内空间中。所以这VirtualBuffer其实就是堆外内存在堆内内存中创建的一个索引，smart-socket在堆内空间中对VirtualBuffer的一切数据读写操作都会同步反应至堆外的DirectByteBuffer中。 图4-1-1 接下来通过几张图示范一下内存池的运作流程。例如： 我们需要一块长度为2的ByteBuffer，那么我们就映射出一个VirtualBuffer占用堆外内存中的两个字节空间。 之后我们还需要一块长度为4的ByteBuffer，那就只能申请下标3至6的空间。 图4-1-2 当虚拟内存使用完毕后，要及时释放占用的堆外内存。 图4-1-3 下一次再需要空间时继续从可用空间中申请。 图4-1-4 ​ 通过不断的申请、释放，smart-socket内存池便运转起来了。需要注意的事，内存的申请是从头到尾进行扫描，而释放回收是无时序的，如图4-1-4。所以在实际运行中会产生一些不连续的小内存块，也就是内存碎片。内存碎片化是个必然存在的状况，假如这种小颗粒内存碎片占比增高，会降低虚拟内存申请的成功率。如果虚拟内存申请失败，smart-socket内存池会启用备用方案,采用申请堆内缓冲区的方式满足应用所需，此类缓冲区使用完毕后可由垃圾回收器释放。这样一种堆外为主，堆内为辅的设计方案，保障了smart-socket内存池的稳定、高效。 4.2 内存池实践 ​ 前文讲完了smart-socket内存池的设计原理，但在实践中还会面临一个情况，便是内存分配、回收时面临的并发问题。尽管只需加同步锁控便能解决，但是在高并发场景下的锁竞争会比较激烈，为了缓解这一状况。smart-socket内存池中引入了内存页BufferPage的概念。内存池中创建一组BufferPage，每个BufferPage各自封装一个大的DirectByteBuffer。再根据特定的分配策略将网络会话AIOSession与某个BufferPage关联起来，由此降低并发情况下的锁竞争压力。 ​ 最终我们的smart-socket内存池实现如下所示。初始化内存池时需要指定内存页的个数，为每个内存页分配的空间大小，以及是否使用直接缓冲区。至于内存页的分配，采用的是轮训策略。 public class BufferPagePool { private BufferPage[] bufferPageList; /** * 内存页游标 */ private int cursor = -1; /** * @param pageSize 内存页大小 * @param poolSize 内存页个数 * @param isDirect 是否使用直接缓冲区 */ public BufferPagePool(final int pageSize, final int poolSize, final boolean isDirect) { bufferPageList = new BufferPage[poolSize]; for (int i = 0; i 4.3 总结 ​ smart-socket内存池的设计可能在理论层面的探讨会更有意义，它所带来的性能提升和内存优化，很轻易的就会被实际业务场景下的系统业务抵消掉。而smart-socket花费大量精力设计的内存池，是为了达到实验室环境下的最优解。框架层面做的每一次努力，都是期望让更多的硬件资源服务于用户的业务，提升资源利用率。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:47:13 "},"smart-socket-v1.4/chapter-6/":{"url":"smart-socket-v1.4/chapter-6/","title":"第五章 未来规划","keywords":"","body":"5.1 应用范围 smart-socket没能赶上互联网发展的最好时机，但有机会搭上物联网发展的高速列车。目前已有不少从事物联网的企业采用smart-socket搭建属于自己的物联网络，相信接下来smart-socket还会有更广阔的应用空间。当然作为一款TCP通信框架，它的适用场景也不限于此，如果您对重复造轮子感兴趣，或许可以颠覆很多现有的解决方案，例如Http服务器、RPC通信框架、即时通讯、游戏开发、网络中间件等。 smart-socket于2017年开源，还是一个非常年轻的项目。从一开始的个人开源项目，到后来的企业级通信解决方案，仅用了不到一年的时间。当然还有很多朋友正处于观望阶段，Netty依旧是大家心目中的首选，但我们坚信smart-socket还有无限的可能性，甚至有朝一日可能如同netty一样成为世界级的项目。但无论未来的路怎样，作为smart-socket的作者，必将不忘初心，坚定项目品质不松懈。 5.2社区发展 从事软件开发的朋友应该会有这样的感受，我们所要学习的技术绝大部分都来源于国外。而学习途径要么是直接阅读官方文档，要么购买中文书籍。两者都存在一些弊端，不少从业人员的英语水平有限，直接阅读英文文档无论效率还是效果都无法得到保障。至于购买的书籍，绝大部分都是对官方文档的翻译，或者只能掌握基本的入门知识。而smart-socket作为一款国产的开源项目，不仅提供了纯中文的参考资料，而且任何人都可以很方便的加入我们的交流社群，所有疑问都能得到及时答复。不仅如此，smart-socket还是基于了国人最朴实的思维方式而设计的，我们并不追求炫技式的设计模式，只期望已最直白的方式实现我们想要的国产通信框架。 无论您还是不是smart-socket的用户，都欢迎加入我们的社群，很期望听到更多的声音，让smart-socket不断的挖掘出自己的潜力，未来走的更稳、更远。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 21:23:38 "},"smart-socket-v1.4/end/":{"url":"smart-socket-v1.4/end/","title":"附录","keywords":"","body":"附录 smart-socket参数配置 配置参数名 功能说明 smart-socket.session.writeChunkSize 输出缓存chunk大小 smart-socket.bufferPool.pageNum 内存池中的缓存页个数 smart-socket.server.pageSize 服务端缓存页大小 smart-socket.client.pageSize 客户端缓存页大小 smart-socket.server.page.isDirect 内存池是否使用直接缓冲区 关于作者 花名：三刀 个人简介：一个写了十年代码的老菜鸟，希望下一个十年能去掉“菜”这个标签。过去一半的工作经历都是外包，现在稳定就职于某电商平台。我们公司还要招人！没错，这是一条招聘广告！ E-mail：zhengjunweimail@163.com 辛辛苦苦写了这么多，是不是应该请作者喝杯咖啡。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:38:02 "},"share/rpc/smart-socket-rpc.html":{"url":"share/rpc/smart-socket-rpc.html","title":"smart-socket实现RPC","keywords":"","body":"smart-socket实现RPC RPC是目前被广泛应用于互联网服务的一项技术，关于它的基本介绍大家可通过百度了解一下，此处不再赘述。 正所谓读万卷书不如行万里路，原理性的文章看的再多都不如亲自实现一遍RPC，方可对其了解的更加透彻。 本文将以纯技术视角，为大家演示一下RPC的工作原理与实现方案。 正式开始之前，先罗列一下实现RPC需要运用到的技术点： 通信 序列化/反序列化 反射 动态代理 在具体实现上除了通信部分我们选用smart-socket来辅助，其余包括序列化/反序列化、反射、动态代理等部分我们将采用JDK提供的解决方案，待您掌握RPC后可再尝试结合第三方技术来重构RPC。 名词解释 Provider RPC服务提供者 Consumer RPC服务调用者 消息通信 既然RPC是跨网络通信服务，那我们先制定通信规则，该部分的内容涉及到通信、序列化/反序列化技术。 通信协议 通信协议我们采用最简单的length+data模式，编解码的实现算法如下。 作为示例我们假设readBuffer足够容纳一个完整的消息，协议中的data部分便是RPC服务序列化后的byte数组，Provider/Consumer则必须对byte数组完成反序列化后才能继续RPC服务处理。 public class RpcProtocol implements Protocol { private static final int INTEGER_BYTES = Integer.SIZE / Byte.SIZE; @Override public byte[] decode(ByteBuffer readBuffer, AioSession session, boolean eof) { int remaining = readBuffer.remaining(); if (remaining remaining) { return null; } byte[] data = new byte[messageSize - INTEGER_BYTES]; readBuffer.getInt(); readBuffer.get(data); return data; } @Override public ByteBuffer encode(byte[] msg, AioSession session) { ByteBuffer byteBuffer = ByteBuffer.allocate(msg.length + INTEGER_BYTES); byteBuffer.putInt(byteBuffer.capacity()); byteBuffer.put(msg); byteBuffer.flip(); return byteBuffer; } } RPC请求消息 RPC请求消息由Consumer发送，Consumer需要在请求消息中提供足够信息以供Provider准确识别服务接口。核心要素包括： uuid 请求消息唯一标识，用于关联、识别响应消息。 interfaceClass Consumer要调用的API接口名 method Consumer要执行的API接口方法名 paramClassList Consumer调用的方法入参类型，用于区分同方法名不同入参的情况 params Consumer执行方法传入的参数值 public class RpcRequest implements Serializable { /** * 消息的唯一标识 */ private final String uuid = UUID.randomUUID().toString(); /** * 接口名称 */ private String interfaceClass; /** * 调用方法 */ private String method; /** * 参数类型字符串 */ private String[] paramClassList; /** * 入参 */ private Object[] params; getX/setX() } RPC响应消息 RPC响应消息为Provider将接口执行结果响应给Consumer的载体。 uuid 与RPC请求消息同值 returnObject RPC接口执行返回值 returnType RPC接口返回值类型 exception RPC执行异常信息，如果出现异常的话。 public class RpcResponse implements Serializable { /** * 消息的唯一标示，与对应的RpcRequest uuid值相同 */ private String uuid; /** * 返回对象 */ private Object returnObject; /** * 返回对象类型 */ private String returnType; /** * 异常 */ private String exception; public RpcResponse(String uuid) { this.uuid = uuid; } getX/setX() } 通过上述内容便完成RPC通信的消息设计，至于RpcRequest、RpcResponse如何转化为通信协议要求的byte数组格式，我们采用JDK提供的序列化方式（生产环境不建议使用）。 序列化ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutput objectOutput = new ObjectOutputStream(byteArrayOutputStream); objectOutput.writeObject(request); aioSession.write(byteArrayOutputStream.toByteArray()); 反序列化ObjectInputStream objectInput = new ObjectInputStream(new ByteArrayInputStream(msg)); RpcResponse resp = (RpcResponse) objectInput.readObject(); RPC服务实现 通过上文方案我们解决了RPC的通信问题，接下来便得根据通信消息实现服务能力。 Consumer 由于RPC的Consumer端只有接口，没有具体实现，但在使用上我们又期望跟本地服务有同样的使用体验。 因此我们需要将接口实例化成对象，并使其具备跨应用服务能力，此处便运用到动态代理。 当Consumer调用RPC接口时，代理类内部发送请求消息至Provider并获取结果。 obj = (T) Proxy.newProxyInstance(getClass().getClassLoader(), new Class[]{remoteInterface}, new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { RpcRequest req = new RpcRequest(); req.setInterfaceClass(remoteInterface.getName()); req.setMethod(method.getName()); Class[] types = method.getParameterTypes(); if (!ArrayUtils.isEmpty(types)) { String[] paramClass = new String[types.length]; for (int i = 0; i Provider Provider可将其提供的RPC服务维护在集合里，采用Map存储即可，key为暴露的接口名，value为接口的具体实现。 一旦Provider接受到RPC的请求消息，只需根据请求消息内容找到并执行对应的服务，最后将返回结果以消息的形式返回至Consumer即可。 ObjectInputStream objectInput = new ObjectInputStream(new ByteArrayInputStream(msg)); RpcRequest req = (RpcRequest) objectInput.readObject(); RpcResponse resp = new RpcResponse(req.getUuid()); try { String[] paramClassList = req.getParamClassList(); Object[] paramObjList = req.getParams(); // 获取入参类型 Class[] classArray = null; if (paramClassList != null) { classArray = new Class[paramClassList.length]; for (int i = 0; i clazz = primitiveClass.get(paramClassList[i]); if (clazz == null) { classArray[i] = Class.forName(paramClassList[i]); } else { classArray[i] = clazz; } } } // 调用接口 Object impObj = impMap.get(req.getInterfaceClass()); if (impObj == null) { throw new UnsupportedOperationException(\"can not find interface: \" + req.getInterfaceClass()); } Method method = impObj.getClass().getMethod(req.getMethod(), classArray); Object obj = method.invoke(impObj, paramObjList); resp.setReturnObject(obj); resp.setReturnType(method.getReturnType().getName()); } catch (InvocationTargetException e) { LOGGER.error(e.getMessage(), e); resp.setException(e.getTargetException().getMessage()); } catch (Exception e) { LOGGER.error(e.getMessage(), e); resp.setException(e.getMessage()); } ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); objectOutput = new ObjectOutputStream(byteArrayOutputStream); objectOutput.writeObject(resp); session.write(byteArrayOutputStream.toByteArray()); 测试RPC服务 服务端定义接口DemoApi，并将其实现示例DemoApiImpl注册至Provider中。 public class Provider { public static void main(String[] args) throws IOException { RpcProviderProcessor rpcProviderProcessor = new RpcProviderProcessor(); AioQuickServer server = new AioQuickServer<>(8888, new RpcProtocol(), rpcProviderProcessor); server.start(); rpcProviderProcessor.publishService(DemoApi.class, new DemoApiImpl()); } } Consumer调用RPC接口test、sum获得执行结果。 public class Consumer { public static void main(String[] args) throws InterruptedException, ExecutionException, IOException { RpcConsumerProcessor rpcConsumerProcessor = new RpcConsumerProcessor(); AioQuickClient consumer = new AioQuickClient<>(\"localhost\", 8888, new RpcProtocol(), rpcConsumerProcessor); consumer.start(); DemoApi demoApi = rpcConsumerProcessor.getObject(DemoApi.class); System.out.println(demoApi.test(\"smart-socket\")); System.out.println(demoApi.sum(1, 2)); } } 总结 本文简要描述了RPC服务实现的关键部分，但是提供稳定可靠的RPC服务还有很多细节需要考虑，有兴趣的朋友可自行研究。 本文示例的完整代码可从smart-socket项目中获取。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-07-01 19:49:04 "},"share/firstfit/readme.html":{"url":"share/firstfit/readme.html","title":"内存管理-首次适应算法","keywords":"","body":"首次适应算法（First-Fit）在smart-socket中的实践 这是一篇关于内存管理算法的文章，对于Java开发者而言这个话题比较遥远。 虽然我们日常开发中一直在跟内存打交道，但很少关注过内存管理的具体细节，毕竟JVM已经做得很好了。 然而在高并发场景下，程序运行过程中产生的大量内存对象，会造成一定的GC负担，由此直接影响着程序运行性能。如果能缓解一部分GC压力，节省下来的系统资源便会对性能有显著的提升，由此便衍生出了池技术。 本次我们分享的内存池技术主要用于提升网络通信的I/O能力，当然该技术也可用于本地磁盘I/O。比较常见的内存管理算法有以下几种： 首次适应算法（First-Fit） 从空闲分区表的第一个表目起查找该表，把最先能够满足要求的空闲区分配给作业，这种方法目的在于减少查找时间。为适应这种算法，空闲分区表(空闲区链)中的空闲分区要按地址由低到高进行排序。该算法优先使用低址部分空闲区，在低址空间造成许多小的空闲区，在高地址空间保留大的空闲区。 优点 该算法倾向于优先利用内存中低址部分的空闲分区，从而保留了高址部分的大空闲区，这为以后到达的大作业分配大的内存空间创造了条件。 缺点 低址部分不断被划分，会留下许多难以利用的，很小的空闲分区，称为碎片。而每次查找又都是从低址部分开始的，这无疑又会增加查找可用空闲分区时的开销。 最佳适应算法（Best-Fit） 从全部空闲区中找出能满足作业要求的、且大小最小的空闲分区，这种方法能使碎片尽量小。为适应此算法，空闲分区表（空闲区链）中的空闲分区要按从小到大进行排序，自表头开始查找到第一个满足要求的自由分区分配。该算法保留大的空闲区，但造成许多小的空闲区。 最差适应算法（Worst-Fit） 它从全部空闲区中找出能满足作业要求的、且大小最大的空闲分区，从而使链表中的结点大小趋于均匀，适用于请求分配的内存大小范围较窄的系统。为适应此算法，空闲分区表（空闲区链）中的空闲分区要按大小从大到小进行排序，自表头开始查找到第一个满足要求的自由分区分配。该算法保留小的空闲区，尽量减少小的碎片产生。 这些算法各有优劣，本次我们只分享首次适应算法，smart-socket中正是应用了该算法实现的高性能通信。 算法原理 接下来我们通过几个步骤来演示内存申请、释放的过程，以及在此过程中如何导致内存碎片化的产生。 初始状态内存容量为：15 ABCDE先后申请特定大小的内存块：1、2、3、4、5，此时内存池中已无可用空间。 B、D释放内存，内存池中出现两块不相邻的内存块。后续再次申请内存便可从这两块不相邻的内存块中挑选可用空间进行分配。 F申请1字节，G申请2字节。按First-Fit算法，会优先从低位查找可用内存块。当F申请到第2位内存块后，紧邻的3号内存块便不再满足G所需的2字节，所以只能从7~10号内存块中申请2字节。如果内存块小到无法满足应用所需，便成了内存碎片。 A、C、E回收内存，内存池中还原出了大片可用区域。如若F、G也释放内存，则次内存池便恢复如初。 算法实践 内存申请 availableBuffers有序存储了内存池申请/释放过程中产生的内存块。低地址内存块存储于队列头部，高地址存于队列尾部。 申请内存时遍历内存块队列，查找容量足够的内存块。 如果内存块容量刚好符合申请所需大小，则从队列中移除该内存块并返回。 如果内存容量大于申请所需大小，则对该内存块进行拆分。只返回所需大小的内存块，剩余部分存留于队列中。 若无可用内存块，则申请失败，此时只能创建临时内存块。public VirtualBuffer allocate(final int size) { lock.lock(); try { Iterator iterator = availableBuffers.iterator(); VirtualBuffer bufferChunk; while (iterator.hasNext()) { VirtualBuffer freeChunk = iterator.next(); final int remaining = freeChunk.getParentLimit() - freeChunk.getParentPosition(); if (remaining 释放内存 使用完毕的内存块需要主动释放回收，以供下次继续使用。释放的过程主要做到两点： 找到被释放内存块在内存队列中的正确点位。 被释放内存块所处的点位若能与前后相邻内存块形成连续内存块，则合并内存块；反之，则直接放入队列中即可。private void clean0(VirtualBuffer cleanBuffer) { int index = 0; Iterator iterator = availableBuffers.iterator(); while (iterator.hasNext()) { VirtualBuffer freeBuffer = iterator.next(); //cleanBuffer在freeBuffer之前并且形成连续块 if (freeBuffer.getParentPosition() == cleanBuffer.getParentLimit()) { freeBuffer.setParentPosition(cleanBuffer.getParentPosition()); return; } //cleanBuffer与freeBuffer之后并形成连续块 if (freeBuffer.getParentLimit() == cleanBuffer.getParentPosition()) { freeBuffer.setParentLimit(cleanBuffer.getParentLimit()); //判断后一个是否连续 if (iterator.hasNext()) { VirtualBuffer next = iterator.next(); if (next.getParentPosition() == freeBuffer.getParentLimit()) { freeBuffer.setParentLimit(next.getParentLimit()); iterator.remove(); } else if (next.getParentPosition() cleanBuffer.getParentLimit()) { availableBuffers.add(index, cleanBuffer); return; } index++; } availableBuffers.add(cleanBuffer); } 完整代码参阅smart-socket项目中的BufferPage.java 拓展讨论 内存申请/释放在实际应用中还有一个无法回避的问题，那就是并发。如何才能在高并发场景下保证内存池依旧能高效稳定的提供申请与释放服务？ 为了避免多线程并发申请导致某块内存区域被多次分配，必须要对申请的过程加同步锁控制，内存释放的过程亦是如此。 可一旦加上同步锁，内存的申请、释放性能必然受到影响。最为理想的状态是每一个CPU绑定着独立的内存池对象， 运行时便不存在多个CPU对同一个内存池对象进行申请/释放操作，这样便可实现无锁化。 可惜CPU绑定内存池的想法无法实现，只能做到线程级的隔离，采用ThreadLocal便可。只不过此方式如若使用不当可能出现内存泄露，以及内存池资源利用率不高等情况。 为此，推荐的做法是采用数组的方式来维护多个内存池对象，使用时通过某种均衡策略将内存池对象分配给任务作业。 虽然不能杜绝锁竞争的情况发生，但在一定程度上还是可以降低锁机率的。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-05-12 21:56:47 "},"donation.html":{"url":"donation.html","title":"关于捐赠","keywords":"","body":"关于捐赠 如果我们的项目对您的学习有所帮助，持续关注并积极反馈就是对我们最大的支持。 如果我们的项目解决了您工作上的难题，不妨请作者喝杯咖啡吧。 如果您的公司认可我们的开源项目，欢迎各种形式的支持。 捐赠清单 姓名 金额 时间 备注 *平 20 2019-06-28 感谢你的付出 拓荒牛 200 2019-04-12 捐赠一个小红包聊表感谢 goodhans 20 2019-04-08 加油！加油！坚持就是胜利！ chen 20 2019-03-15 钱不多，算是给三哥的开源精神的一点点鼓励 陈旭员 20 2019-03-15 码云捐赠 wbstc 20 2019-03-01 QQ:457319664 *一晗 50 2019-01-08 感谢你的smart文档！感谢你的付出! noear 999 2018-12-27 Tsukasa 100 2018-08-10 noear 200 2018-06-12 萨博 50 2018 逼捐 龙马 50 2018 逼捐 贝尔 50 2018 逼捐 liweibo 99 2018 zhengwen6300 10 2018 刀锋剑雨 20 2018 小仙女 10 2017 捐赠入口 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-06-28 16:52:08 "}}