{"./":{"url":"./","title":"关于smartboot","keywords":"","body":"关于smartboot 一个人的开源组织。 作品 smart-socket 仅800多行代码实现极简、易用、高性能的java AIO通信框架，也许是IM、RPC、IoT开发的最佳选择 smart-boot 基于springboot封装的微服务框架 somart-ioc Java NIO实现的smart-socket android 版通信框架 maven-mydalgen-plugin mybatis代码自动生成的Maven插件，简化sql书写，避免大量动态sql。 分享 暂无 成员 三刀 加入方式： 方式一：捐赠smartboot ￥1,000,000。 方式二： 发表smartboot任一项目文章并获得1W以上的阅读量，不限平台。 开源作者或为开源作出过贡献。 smartboot成员认可。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-14 19:52:10 "},"smart-socket/":{"url":"smart-socket/","title":"前言","keywords":"","body":"smart-socket是什么 smart（百度翻译：聪明的;敏捷的;漂亮的;整齐的），从为项目起名开始，便对其寄予了厚望。专注于通信组件的研究与发展，摒弃一切大而全的解决方案，仅提供小而美的基础服务。无论您是从事IOT、IM、RPC，还是其余通信领域的开发工作，相信smart-socket都是非常酷的选择。如果要用一句话来为smart-socket打call,那就是：遇见smart-socket，你就已经赢在起跑线了。 关于开源 JDK7虽然已经发布很长一段时间了，但开源社区对于其AIO的新特性貌似并不热情。对于通信方面的技术诉求，似乎大家都习惯于Netty、Mina。“Stop Trying to Reinvent the Wheel”不要重复造轮子，几乎每个程序员都被灌输过这个概念，理所当然的沉浸在各自的舒适区，享受着开源社区提供的各项技术支撑。举个跟本文相契合的例子，如果工作中遇到通信相关的需求，广大Java程序员脑海里首先想到的必然是Netty或Mina，即便从未接触过Netty/Mina，但在心里认定只有这两个框架才能解决自己面临的问题。这样的现状可能归咎于现在我们太急躁，工作的压力致使没时间给自己充电，尤其是那种不常用且稍微有点深度的技术点，已经没心力再去细细琢磨了。所幸还有一批好学的程序员在工作之余做着一些看似平凡的事，踏踏实实专研这些技术点并作出一些小小的作品，同时为开源社区注入新鲜血液。目前码云上已知的Java AIO项目有Voovan、baseio以及本文的主角：smart-socket，这几个作品还无任何一款能形成足够的影响力被广大Javaer认可，但通过开源的推广与磨练，相信未来AIO的开源环境会比现在更加繁荣。 smart-socket立项之初便已严苛的要求进行开发，追求各方面都达到极致。首先，smart-socket是个非常轻量级的项目，只有依赖slf4j作为项目的日志组件。smart-socket发布的jar包仅仅20KB，简洁的接口设计可以非常方便的在业务中接入通信服务。不过我们更期望看到的是接触到smart-socket的朋友可以将其作为学习Java Socket编程的素材，如果smart-socket能在这方面给予您一丝帮助，那我便会绝对自己做了一件有意义的事。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-14 21:10:43 "},"smart-socket/quickStart.html":{"url":"smart-socket/quickStart.html","title":"快速上手","keywords":"","body":" 官方指南假设您已了解ByteBuffer，并对Socket编程具备一定基础。如果您刚开始接触Socket，将smart-socket作为您的第一步可能不是个好的决定。 Maven依赖 smart-socket已上传至Maven仓库，使用前需要向其引入您的项目工程中。 org.smartboot.socket aio-core 1.3.11 通信开发 基于smart-socket进行通信服务的开发，主要有三个步骤： 协议编解码 消息处理 启动服务 接下来我们会通过一个简单例子来演示如何通过smart-socket开发服务端与客户端程序。为简化操作，服务端与客户端交互的数据为一个整型数据。 一、协议编解码 通常情况下服务端与客户端通信遵循同一套协议规则，因此我们只需编写一份协议编解码实现即可（如果是跨语言则需要各自实现）。如下所示，协议编解码的需要实现接口Protocol。 public class IntegerProtocol implements Protocol { private static final int INT_LENGTH = 4; @Override public Integer decode(ByteBuffer data, AioSession session, boolean eof) { if (data.remaining() session) { ByteBuffer b = ByteBuffer.allocate(INT_LENGTH); b.putInt(s); b.flip(); return b; } } 上述代码很简单，一个整数的长度为4byte，所以只要长度大于等于4，我们就能解析到一个整数。 值得注意的是，通过Protocol实现编码encode算法后，开发人员需要确保返回的ByteBuffer是出于可读状态。正如例子所示，完成编码后执行了flip()方法。 二、消息处理 业务消息的处理需要实现接口MessageProcessor，该接口只有两个方法：process,stateEvent。其中 stateEvent用于定义AioSession状态机的监控与处理。process则会处理每一个接收到的业务消息。 服务端 public class IntegerServerProcessor implements MessageProcessor { @Override public void process(AioSession session, Integer msg) { Integer respMsg = msg + 1; System.out.println(\"接受到客户端数据：\" + msg + \" ,响应数据:\" + (respMsg)); try { session.write(respMsg); } catch (IOException e) { e.printStackTrace(); } } @Override public void stateEvent(AioSession session, StateMachineEnum stateMachineEnum, Throwable throwable) { } } 客户端 public class IntegerClientProcessor implements MessageProcessor { private AioSession session; @Override public void process(AioSession session, Integer msg) { System.out.println(\"接受到服务端响应数据：\" + msg); } @Override public void stateEvent(AioSession session, StateMachineEnum stateMachineEnum, Throwable throwable) { switch (stateMachineEnum) { case NEW_SESSION: this.session = session; break; default: System.out.println(\"other state:\" + stateMachineEnum); } } public AioSession getSession() { return session; } } 三、启动服务 服务端 public class IntegerServer { public static void main(String[] args) throws IOException { AioQuickServer server = new AioQuickServer(8888, new IntegerProtocol(), new IntegerServerProcessor()); server.start(); } } 客户端 public class IntegerClient { public static void main(String[] args) throws Exception { IntegerClientProcessor processor = new IntegerClientProcessor(); AioQuickClient aioQuickClient = new AioQuickClient(\"localhost\", 8888, new IntegerProtocol(), processor); aioQuickClient.start(); processor.getSession().write(1); Thread.sleep(1000); aioQuickClient.shutdown(); } } Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-14 21:05:42 "},"smart-socket/first/1-ready.html":{"url":"smart-socket/first/1-ready.html","title":"准备工作","keywords":"","body":"一、准备工作 本章节作为基础篇，旨在表达smart-socket灵魂部分的实现原理，这将有助于您更好的运用smart-socket写出高效的程序。本手册描述的内容仅限于smart-socket，不涉及到Java Socket基础知识，所以在阅读之前请确认你已具备初步的socket开发经验并对JDK AIO相关的类/接口有所了解： AsynchronousChannelGroup AsynchronousServerSocketChannel AsynchronousSocketChannel CompletionHandler smart-socket为自己贴的标签是：极简、易用、高性能。文字无法表达的它的“高性能”程度，以您的亲测结果为准。至于“极简”、“易用”的特性，希望通过本文的阐述让你切身感受到。smart-socket代码总量仅800多行，源码文件数也才区区11个。引用smart-socket的服务很简单，直接通过maven将其引入到您的工程中即可。 org.smartboot.socket aio-core 1.3.10 smart-socket代码清单 名称 类型 可见性 说明 Protocol interface public 协议接口 MessageProcessor interface public 消息处理器接口 Filter interface public 过滤器接口 StateMachineEnum enum public 服务状态机枚举 AioQuickClient class public AIO客户端 AioQuickServer class public AIO服务端 AioSession class public AIO传输会话 IoServerConfig class package AIO服务配置 ReadCompletionHandler class package AIO读操作CompletionHandler实现类 WriteCompletionHandler class package AIO写操作CompletionHandler实现类 FastBlockingQueue class package 自定义队列 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-05-28 20:37:47 "},"smart-socket/first/2-core-interface.html":{"url":"smart-socket/first/2-core-interface.html","title":"核心接口","keywords":"","body":"二、核心接口 作为一款框架，需要具备支持各类业务场景的能力，但框架本身又无法知晓实际业务场景如何，因此需要设计一套扩展性强且优雅的接口。smart-socket中核心的接口仅3个，用户在使用smart-socket进行二次开发时，也只需熟练掌握这三个接口的运用即可。 剧透：在基础篇中可无需关注Filter，您对smart-socket的使用不受其影响，在进阶篇中另有讲解。 Protocol public interface Protocol { /** * 对于从Socket流中获取到的数据采用当前Protocol的实现类协议进行解析 * * @param data * @param session * @param eof 是否EOF * @return 本次解码所成功解析的消息实例集合, 返回null则表示解码未完成 */ public T decode(final ByteBuffer data, AioSession session, boolean eof); /** * 将业务消息实体编码成ByteBuffer用于输出至对端。 * 切勿在encode中直接调用session.write,编码后的byteuffer需交由框架本身来输出 * * @param msg * @param session * @return */ public ByteBuffer encode(T msg, AioSession session); } Protocol是一个泛型接口，指的是业务消息实体类，smart-socket中不少地方都运用了泛型设计，其含义都代表消息类型。Protocol定义了消息编解码的接口，我们先来了解一下其中的两个方法decode、encode。 decode消息解码，AIO的数据传输是以ByteBuffer为媒介的。在读取到数据并填充到ByteBuffer后，smart-socket会调用Protocol实现类的decode方法，并将ByteBuffer作为第一个参数传入，而第二个参数AioSession为当前Socket连接的会话对象，后续会详解。Protocol实现类从ByteBuffer中读取字节并按其协议规则进行消息解码，待解码完成后封装成业务对象并返回。不过实际情况下，已读取到并传入ByteBuffer的字节可能不足以完成消息解码（即所谓的：半包/拆包），Protocol实现类可根据其实际情况选择部分解码或等待ByteBuffer足以完成解码后再执行解码操作，不过在消息未完成解码的情况下必须返回null。 encode消息编码，业务消息在输出至网络对端前，需要将其编码成字节流，也是以ByteBuffer为载体的。该方法的第一个参数泛型T便是业务消息对象。Protocol的实现类也得按照业务规则，将T指代的对象转为ByteBuffer并返回，smart-socket会将编码后的ByteBuffer输出。 MessageProcessor public interface MessageProcessor { /** * 处理接收到的消息 * * @param session * @throws Exception */ public void process(AioSession session, T msg); /** * 状态机事件,当枚举事件发生时由框架触发该方法 * * @param session * @param stateMachineEnum 状态枚举 * @param throwable 异常对象，如果存在的话 */ void stateEvent(AioSession session, StateMachineEnum stateMachineEnum, Throwable throwable); } MessageProcessor定义了消息处理器接口，smart-socket在通过Protocol完成消息解码后，会将消息对象交由MessageProcessor实现类进行业务处理。 process消息处理器，smart-socket每接收到一个完整的业务消息，都会交由该处理器执行。 stateEvent执行状态机，smart-socket内置了状态枚举StateMachineEnum。MessageProcessor实现类可在此方法中处理其关注的事件。 Filter Filter是框架提供的通信层过滤器接口，用户可基于该接口开发一些扩展性服务。这个接口不常用，但利用的好的话可以帮助你获悉服务器的运行状况。 public interface Filter { /** * 数据读取过滤,可用于统计流量 * * @param session * @param readSize 本次解码读取的数据长度 */ public void readFilter(AioSession session, int readSize); /** * 消息处理前置预处理 * * @param session * @param msg 编解码后的消息实体 */ public void processFilter(AioSession session, T msg); /** * 消息接受失败处理 * * @param session * @param msg 编解码后的消息实体 * @param e 本次处理异常对象 */ public void processFailHandler(AioSession session, T msg, Throwable e); /** * 数据输出过滤,可用于统计流量 * * @param session * @param writeSize 本次输出的数据长度 */ public void writeFilter(AioSession session, int writeSize); } readFilter读操作过滤，每当smart-socket发生读操作便会触发该方法。第一个参数AioSession为本次发生读事件的会话，第二个参数readSize为本次读取到的字节数 processFilter消息处理过滤器，每一个业务消息在执行MessageProcessor.process之前都会先执行一遍Filter.processFilter processFailHandler当业务消息执行processFilter出现运行时异常时，会触发processFailHandler writeFilter写操作过滤，每当smart-socket发生写操作便会触发该方法。第一个参数AioSession为本次发生写事件的会话，第二个参数writeSize为本次输出的字节数 smart-socket的运行并非强依赖Filter，因此用户未定义Filter也不会影响使用，该接口只是框架的一项附加功能。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-05-28 20:42:06 "},"smart-socket/first/3-enum.html":{"url":"smart-socket/first/3-enum.html","title":"枚举状态","keywords":"","body":"三、状态枚举 状态机StateMachineEnum smart-socket中引入了状态机的概念，框架会监控每个状态事件的发生并通知消息处理器MessageProcessor的实现类。因此在必要的情况下，用户需要在stateEvent实现自己所要关注的状态处理，例如： public void stateEvent(AioSession session, StateMachineEnum stateMachineEnum, Throwable throwable) { switch (stateMachineEnum) { case NEW_SESSION: newSession(); break; case INPUT_SHUTDOWN: inputShutdown(); break; } } 目前已有的状态枚举为： 状态枚举 说明 NEW_SESSION 网络连接建立时触发，连接建立时会构建传输层的AioSession，如果业务层面也需要维护一个会话，可在此状态机中处理 INPUT_SHUTDOWN 数据读取完毕时触发，即传统意义中的read()==-1 INPUT_EXCEPTION 读数据过程中发生异常时触发此状态机 OUTPUT_EXCEPTION 写数据过程中发生异常时触发此状态机 SESSION_CLOSING 触发了AioSession.close方法，但由于当前AioSession还有未完成的事件，会进入SESSION_CLOSING状态 SESSION_CLOSED AioSesson完成close操作后触发此状态机 PROCESS_EXCEPTION 业务处理异常 RELEASE_FLOW_LIMIT 释放流控,仅服务端有效 FLOW_LIMIT 流控,仅服务端有效 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-05-28 20:47:10 "},"smart-socket/first/4-IoServerConfig.html":{"url":"smart-socket/first/4-IoServerConfig.html","title":"服务配置IoServerConfig","keywords":"","body":"四、服务配置IoServerConfig IoServerConfig是个包可见级别的类，供smart-socket进行服务配置管理，用户无法直接对其操作。但是了解该类有助于更好的运用smart-socket开放的各个接口。 配置项 类型 默认值 备注 BANNER String - 控制台打印的启动banner VERSION String v1.3.10 当前smart-socket版本号 writeQueueSize int 4 AioSession中的输出缓存队列长度 readBufferSize int 512 AioSession进行数据读操作是ByteBuffer大小,单位：byte host String null 客户端连接远程服务器的地址 filters Filter数组 [ ] 定义过滤器数组 port int 8888 服务端开放的端口号 processor MessageProcessor null 自定义消息处理器 protocol Protocol null 自定义协议编解码 threadNum int CPU Nums smart-socket线程组大小 limitRate float 0.9 流控系数，该配置项由框架维护，无法修改 releaseRate float 0.6 解除流控系数，该配置项由框架维护，无法修改 flowLimitLine int limitRate*writeQueueSize 触发流控的阈值，无法修改 releaseLine int releaseRate*writeQueueSize 解除流控的阈值，无法修改 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-05-28 20:47:39 "},"smart-socket/first/5-AioQuickServer.html":{"url":"smart-socket/first/5-AioQuickServer.html","title":"服务端AioQuickServer","keywords":"","body":"五、服务端AioQuickServer 成员属性 属性名 类型 说明 serverSocketChannel AsynchronousServerSocketChannel JDK提供的AIO服务端核心类 asynchronousChannelGroup AsynchronousChannelGroup JDK为AIO提供的线程池服务 config IoServerConfig 存储AioQuickServer服务配置项 aioReadCompletionHandler ReadCompletionHandler smart-socket提供的IO读回调处理类 aioWriteCompletionHandler WriteCompletionHandler smart-socket提供的IO写回调处理类 配置型方法 方法 说明 public AioQuickServer setBannerEnabled(boolean bannerEnabled) 服务启动时是否打印smart-socket banner public AioQuickServer setDirectBuffer(boolean directBuffer) 是否启用DirectByteBuffer public AioQuickServer setThreadNum(int num) Server服务线程数 public AioQuickServer setFilters(Filter... filters) 注册服务过滤器 public AioQuickServer setWriteQueueSize(int size) 设置AioSession输出缓存区长度 public AioQuickServer setReadBufferSize(int size) 设置AioSession读缓存区长度 public AioQuickServer setOption(SocketOption socketOption, V value) 设置Socket的TCP参数配置 核心方法 1、 start：启动AIO服务端 片段一 asynchronousChannelGroup = AsynchronousChannelGroup.withFixedThreadPool(config.getThreadNum(), new ThreadFactory() { byte index = 0; @Override public Thread newThread(Runnable r) { return new Thread(r, \"AIO-Thread-\" + (++index)); } }); 初始化AIO服务的工作线程组并赋值于AioQuickServer成员属性asynchronousChannelGroup 片段二this.serverSocketChannel = AsynchronousServerSocketChannel.open(asynchronousChannelGroup).bind(new InetSocketAddress(config.getPort()), 1000); 这行代码很直观，打开AIO服务通道并绑定端口号，但要注意bind方法。AsynchronousServerSocketChannel提供了两个bind接口：bind(SocketAddress local)，bind(SocketAddress local, int backlog)如果调用bind(SocketAddress local)方法，AsynchronousServerSocketChannel内部实际上执行的是bind(SocketAddress local, 0)。然而backlog的值小于1时，JDK会将其默认设置为50。 backlog维护了连接请求队列长度，如果队列满时收到连接指示，则拒绝该连接。举个例子：backlog设置为50，当前有50连接请求过来，服务端还未执行这些连接请求的accept方法。此时再有一个连接请求过来，则会被拒绝连接。除非请求队列中的某个连接完成accept操作并释放出队列资源，服务器才可接受新的连接。 片段三 serverSocketChannel.accept(null, new CompletionHandler() { @Override public void completed(final AsynchronousSocketChannel channel, Object attachment) { serverSocketChannel.accept(attachment, this); createSession(channel); } @Override public void failed(Throwable exc, Object attachment) { LOGGER.warn(exc); } }); protected void createSession(AsynchronousSocketChannel channel) { AioSession session = new AioSession(channel, config, aioReadCompletionHandler, aioWriteCompletionHandler, true); session.initSession(); } AIO通道服务监听客户端连接请求，一旦客户端连接上来则触发CompletionHandler回调。CompletionHandler首先要做的便是继续下一个请求的监听serverSocketChannel.accept(attachment, this);，然后构建本次连接的会话对象AioSession。 所有的AioSession共用aioReadCompletionHandler、aioWriteCompletionHandler对象，这样可以减少服务端产生的对象数。 之所以定义createSession来实现AIOSession初始化，是为了预留扩展接口。后续进行TLS/SSL通讯时，createSession会有不同的实现。 2、 shutdown：停止AIO服务端 AIO服务停止的逻辑很简单，关闭Channel通道，停止线程组。 public void shutdown() { try { serverSocketChannel.close(); } catch (IOException e) { LOGGER.catching(e); } asynchronousChannelGroup.shutdown(); } Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-05-28 21:02:04 "},"smart-socket/first/6-AioQuickClient.html":{"url":"smart-socket/first/6-AioQuickClient.html","title":"客户端AioQuickClient","keywords":"","body":"六、客户端AioQuickClient 成员属性 属性名 类型 说明 socketChannel AsynchronousSocketChannel JDK提供的AIO客户端核心类 asynchronousChannelGroup AsynchronousChannelGroup JDK为AIO提供的线程池服务 config IoServerConfig 存储AioQuickClient服务配置项 配置型方法 方法 说明 public AioQuickClient connect(String host, int port) 设置远程连接的地址、端口 public AioQuickClient setProtocol(Protocol protocol) 注册协议编解码实现 public AioQuickClient setFilters(Filter[] filters) 注册服务过滤器 public AioQuickClient setProcessor(MessageProcessor processor) 注册业务处理器 public AioQuickClient setReadBufferSize(int size) 设置读缓冲区大小 public AioQuickClient setWriteQueueSize(int size) 设置AioSession输出缓存区队列长度 核心方法 1、start(AsynchronousChannelGroup asynchronousChannelGroup)： 启动AIO客户端服务 public void start(AsynchronousChannelGroup asynchronousChannelGroup) throws IOException, ExecutionException, InterruptedException { this.socketChannel = AsynchronousSocketChannel.open(asynchronousChannelGroup); socketChannel.connect(new InetSocketAddress(config.getHost(), config.getPort())).get(); //连接成功则构造AIOSession对象 AioSession session = new AioSession(socketChannel, config, new ReadCompletionHandler(), new WriteCompletionHandler(), false); session.initSession(); } 该方法支持外部传入服务线程组AsynchronousChannelGroup，当一个应用要启动多个客户端时，采用该方式有助于提升资源利用率。客户端连接服务器的过程并没有采用CompletionHandler的方案，是因为作者认为作为客户端，采用Future模式可以降低代码复杂度，接口功能更直观。因为对于业务来说，一旦start方法执行完毕，连接就必须是建立成功的。网络连接建立完毕之后，就会构建客户端的通信会话AioSession。 2、start() public void start() throws IOException, ExecutionException, InterruptedException { this.asynchronousChannelGroup = AsynchronousChannelGroup.withFixedThreadPool(2, new ThreadFactory() { @Override public Thread newThread(Runnable r) { return new Thread(r); } }); start(asynchronousChannelGroup); } 如果客户端要使用私有的线程组，可调用不带参数的start方法。单客户端只有读、写两类操作，所以线程大小设置为2足矣。且私有的线程组需要赋值于成员属性asynchronousChannelGroup,以便客户端执行shutdown时可以进行资源释放。 3、shutdown() 代码简单，不解释 public void shutdown() { if (socketChannel != null) { try { socketChannel.close(); } catch (IOException e) { LOGGER.catching(e); } } //仅Client内部创建的ChannelGroup需要shutdown if (asynchronousChannelGroup != null) { asynchronousChannelGroup.shutdown(); } } Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-05-27 14:34:42 "},"smart-socket/first/7-AioSession.html":{"url":"smart-socket/first/7-AioSession.html","title":"通信会话AioSession","keywords":"","body":"七、通信会话AioSession AioSession是smart-socket中最核心、复杂度最高的类 核心成员属性 属性名 类型 说明 NEXT_ID static int Session ID生成器 sessionId final int Session ID，值取自++NEXT_ID status byte 当前会话的状态，取值范围：SESSION_STATUS_CLOSED(1)，处于该状态的AioSession无法再进行读写操作；SESSION_STATUS_CLOSING(2)，AioSession状态从SESSION_STATUS_ENABLED到SESSION_STATUS_CLOSED的过渡状态。在SESSION_STATUS_CLOSING状态下，AioSession不接受新的读写请求，但会把缓存中待输出的数据进行写操作，输出完毕后更改状态至SESSION_STATUS_CLOSED；SESSION_STATUS_ENAB(3)，AioSessio的默认状态，表示当前会话状态可以进行正常的消息通信、协议编解码、业务处理业务处理 attachment Object 附件对象 writeCacheQueue ArrayBlockingQueue 输出缓冲队列 serverFlowLimit Boolean 限流标志，仅服务端有值，客户端为null readCompletionHandler ReadCompletionHandler 读回调 writeCompletionHandler WriteCompletionHandler 写回调 channel AsynchronousSocketChannel 当前AioSession映射的网络通道 semaphore Semaphore 信号量，控制输出资源的竞争 ioServerConfig IoServerConfig AioQuickClient\\AioQuickServer透传过来的配置项 核心方法 方法名 说明 AioSession(AsynchronousSocketChannel, IoServerConfig, ReadCompletionHandler, WriteCompletionHandler, boolean serverSession) 唯一的一个构造方法 void readFromChannel() 数据解码——>业务处理——>注册读事件 public void write(final ByteBuffer buffer) 将编码后的业务消息写入缓冲区，并触发writeToChannel() void writeToChannel() 将缓冲区的数据写入至网络通道 public void close(boolean immediate) 关闭会话 1、构造方法 AioSession(AsynchronousSocketChannel channel, IoServerConfig config, ReadCompletionHandler readCompletionHandler, WriteCompletionHandler writeCompletionHandler, boolean serverSession) { this.channel = channel; this.readCompletionHandler = readCompletionHandler; this.writeCompletionHandler = writeCompletionHandler; this.writeCacheQueue = new ArrayBlockingQueue(config.getWriteQueueSize()); this.ioServerConfig = config; this.serverFlowLimit = serverSession ? false : null; config.getProcessor().stateEvent(this, StateMachineEnum.NEW_SESSION, null);//触发状态机 this.readBuffer = ByteBuffer.allocate(config.getReadBufferSize()); } 该构造方法是包可见的，所以只有smart-socket才可创建AioSession对象。对象的创建入口为AioQuickServer和AioQuickClient。 构造方法的5个入参分别代表，channe：当前连接通道对象；config：AioQuickServer/AioQuickClient服务器配置；readCompletionHandler/writeCompletionHandler：读写回调处理类；serverSession：true表示当前Session的由服务端创建，否则为客户端创建。 writeCacheQueue，创建输出缓冲区。该缓冲区大小请设置一个合理的值，以免造成资源浪费。 serverFlowLimit，流控标志。流控方案仅存在于服务端，所以只有AioQuickServer构建的AioSession对象会初始化该值。 触发状态机StateMachineEnum.NEW_SESSION 2、readFromChannel() readFromChannel是专门用于处理读回调（ReadCompletionHandler）的接口，使读监控->数据读取->协议解码->业务处理->继续读监控 形成一个良性的运作状态。且具体实现分为三部分： 片段一解码已读取到数据，若解码成功则进行业务处理，直至当前剩余的数据无法解析成完整的业务消息为止。 T dataEntry; while ((dataEntry = ioServerConfig.getProtocol().decode(readBuffer, this, eof)) != null) { //处理消息 try { for (Filter h : ioServerConfig.getFilters()) { h.processFilter(this, dataEntry); } ioServerConfig.getProcessor().process(this, dataEntry); } catch (Exception e) { logger.catching(e); for (Filter h : ioServerConfig.getFilters()) { h.processFail(this, dataEntry, e); } } } 片段二 通过片段一执行后的readBuffer有三种结果：1、数据刚好完全解析完，调用clear()重置；2、完成了解码操作，但还残留部分未解析的数据，则将剩余的数据转移至ByteBuffer的头部；3、原先已有的数据不满足解码条件，则恢复现场，继续读。 if (readBuffer.remaining() == 0) { readBuffer.clear(); } else if (readBuffer.position() > 0) { readBuffer.compact(); } else { readBuffer.position(readBuffer.limit()); readBuffer.limit(readBuffer.capacity()); } 片段三 如果触发了流控条件，则设置流控标志serverFlowLimit = true。否则继续新一轮的读操作，一旦读取到数据，会由aioCompletionHandler再次触发readFromChannel()方法 if (serverFlowLimit != null && writeCacheQueue.size() > ioServerConfig.getFlowLimitLine()) { serverFlowLimit = true; } else { continueRead(); } 3、write(ByteBuffer buffer) 先将数据存入缓冲区writeCacheQueue。采取尝试获取信号量semaphore，获取成功触发通道的输出操作。此处之所以引入了信号量semaphore，是因为writeToChannel()可能由业务线程通过write调用，也有可能由WriteCompletionHandler的回调触发，如果不处理好同步控制，会出现WritePendingException。 public void write(final ByteBuffer buffer) throws IOException { if (isInvalid()) { return; } try { writeCacheQueue.put(buffer); } catch (InterruptedException e) { logger.error(e); } if (semaphore.tryAcquire()) { writeToChannel(); } } 4、writeToChannel wrtie只是面向业务的输出行为，真正执行数据输出的是writeToChannel。个人认为该方法是整个smart-socket复杂度最高的代码，需要具备一定程度的线程同步知识才能完全理解代码意义。执行writeToChannel之前，必须持有信号量semaphore 片段一若前一次输出操作还残留部分数据，继续执行输出，否则释放其内存空间。if (writeAttach.buffer != null && writeAttach.buffer.hasRemaining()) { continueWrite(); return; } writeAttach.buffer = null;//释放对象 片段二判断当前是否存在待输出的数据，若已无可输出的数据，则释放信号量资源。但是在释放信号量之后的瞬间可能有新的数据进入缓冲区，因此需要再次争抢信号量资源并重新触发writeToChannel。 if (writeCacheQueue.isEmpty()) { semaphore.release(); if (isInvalid()) {//此时可能是Closing或Closed状态 close(); } else if (writeCacheQueue.size() > 0 && semaphore.tryAcquire()) { writeToChannel(); } return; } 片段三压缩缓冲区中待输出的数据，且最大的压缩字节长度为32*1024 Iterator iterable = writeCacheQueue.iterator(); int totalSize = 0; while (iterable.hasNext() && totalSize 片段四构建压缩后的ByteBuffer对象执行数据输出。writeAttach.buffer = ByteBuffer.wrap(data); continueWrite(); 5、tryReleaseFlowLimit 判断当前AioSession是否处理限流状态，若符合解除限流条件，则释放流控，并重新进行数据读取。处于限流状态的AioSession必然不存在读操作，所以此处可放心的执行channel.read(); if (serverFlowLimit != null && serverFlowLimit && writeCacheQueue.size() 6、close 关闭当前会话，当入参为true或缓冲区已清空时，直接关闭当前会话。否则切换会话状态为SessionStatus.SESSION_STATUS_CLOSING直至缓存区被清空再执行关闭。 public void close(boolean immediate) { if (status == SESSION_STATUS_CLOSED) { logger.warn(\"ignore, session:{} is closed:\", getSessionID());//说明close方法被重复调用 return; } status = immediate ? SESSION_STATUS_CLOSED : SESSION_STATUS_CLOSING; if (immediate) { try { channel.close(); if (logger.isDebugEnabled()) { logger.debug(\"session:{} is closed:\", getSessionID()); } } catch (IOException e) { logger.catching(e); } ioServerConfig.getProcessor().stateEvent(this, StateMachineEnum.SESSION_CLOSED, null); } else if ((writeBuffer == null || !writeBuffer.hasRemaining()) && writeCacheQueue.isEmpty() && semaphore.tryAcquire()) { close(true); semaphore.release(); } else { ioServerConfig.getProcessor().stateEvent(this, StateMachineEnum.SESSION_CLOSING, null); } } Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-05-27 14:34:42 "},"smart-socket/first/8-CompletionHandler.html":{"url":"smart-socket/first/8-CompletionHandler.html","title":"读写回调","keywords":"","body":"八、读写回调 读回调ReadCompletionHandler class ReadCompletionHandler implements CompletionHandler> { private static final Logger LOGGER = LogManager.getLogger(ReadCompletionHandler.class); @Override public void completed(final Integer result, final AioSession aioSession) { // 接收到的消息进行预处理 for (Filter h : aioSession.getServerConfig().getFilters()) { h.readFilter(aioSession, result); } aioSession.readFromChannel(result == -1); } @Override public void failed(Throwable exc, AioSession aioSession) { if (exc instanceof IOException) { if (LOGGER.isDebugEnabled()) { LOGGER.debug(\"session:{} will be closed,msg:{}\", aioSession.getSessionID(), exc.getMessage()); } } else { if (LOGGER.isDebugEnabled()) { LOGGER.debug(\"smart-socket read fail:\", exc); } } try { aioSession.getServerConfig().getProcessor().stateEvent(aioSession, StateMachineEnum.INPUT_EXCEPTION, exc); } catch (Exception e) { LOGGER.catching(e); } try { aioSession.close(); } catch (Exception e) { LOGGER.catching(e); } } } 执行读回调是为了处理当前从网络上读取到的字节流，在AIO通信中被封装为ByteBuffer对象。我们需要对这些数据进行解析，还原成消息实体并进行业务处理。 满足以下任何一个条件时，都会触发读回调： 从网络上读取到新的数据，至少1个字节。 对端服务完成输出并关闭write通道，即本通道的read操作已终止，此时result==-1。如图所示： 当服务在进行数据读取、或者读回调处理过程中出现异常时，会触发ReadCompletionHandler的failed方法。框架会触发StateMachineEnum.INPUT_EXCEPTION状态机，业务自行决定是否处理。为了规避开发人员忽略此类异常导致资源无法释放，smart-socket会主动执行AioSession.close。 写回调WriteCompletionHandler class WriteCompletionHandler implements CompletionHandler> { private static final Logger LOGGER = LogManager.getLogger(WriteCompletionHandler.class); @Override public void completed(final Integer result, final AioSession aioSession) { // 接收到的消息进行预处理 for (Filter h : aioSession.getServerConfig().getFilters()) { h.writeFilter(aioSession, result); } aioSession.writeToChannel(); } @Override public void failed(Throwable exc, AioSession aioSession) { if (LOGGER.isDebugEnabled()) { LOGGER.debug(\"smart-socket write fail:\", exc); } try { aioSession.getServerConfig().getProcessor().stateEvent(aioSession, StateMachineEnum.OUTPUT_EXCEPTION, exc); } catch (Exception e) { LOGGER.catching(e); } try { aioSession.close(); } catch (Exception e) { LOGGER.catching(e); } } } 业务实现中会通过AioSession.write给予对端响应消息，这个write操作是非阻塞的。当数据输出后会以写回调WriteCompletionHandler的方式告知框架，已经有一部分数据成功写出去了。每次触发回调后都需要检查是否还有待输出的数据，若有则继续执行write方法，并等待下一次写回调。自此数据输出操作便形式一个健康的执行闭环。 当然这个输出的过程会如同写操作一样出现不可预知的异常，此时同样会通过WriteCompletionHandler.failed方法触发状态机StateMachineEnum.OUTPUT_EXCEPTION，最后框架自动关闭连接释放资源。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-05-27 14:34:42 "},"smart-socket/second/readme.html":{"url":"smart-socket/second/readme.html","title":"开篇概述","keywords":"","body":"开篇概述 在基础篇中主要讲解的还是smart-socket的基本用法，可做为入门教程。然而实战过程中面临的情况会相对复杂一点，\b驾驭smart-socket更需要掌握一些技巧性的操作。在进阶篇中会介绍常见的几类场景，并提供相应的应对策略。 在正式讲解之前我们先来对常见的几种消息进行分类，方便大家理解消化。后续在工作终于遇到问题时可按照本文定义的类别寻找相应的解决方法。注意，此处讲的是“消息”，并非协议，可能有人疑惑这两者的区别。用面向对象的思想简单理解就是：协议等同于class，消息就是class实例化后的object。为了便于区分，我们将消息分类以下几种： 一类消息服务端与客户端之间通信的所有消息大小都是在一定范围内的，AIOSession的readBuffer容量完全可以承载至少一个消息（前提是readBuffer的容量本身就设置了一个“合理”的数值）。这个“合理”的定义是ReadBuffer容量尽可能的满足绝大部分消息长度，且数值不会超过一定阈值。假设我们暂定readBuffer的容量阈值为1024，那么以下几种消息则属于一类消息： 所有消息长度都小于100，readBuffer设置容量为100 消息长度范围[0,512)，readBuffer容量设置为512 消息长度范围[0,1024),readBuffer容量设置为1024 那如果消息长度范围为[0,2048)呢，我们是否可以通过将readBuffer容量设置为2048来满足我们的需求？答案是否定的，如果绝大部分情况下消息大小在1024内，仅少量的消息大小在[1024,2048)区间内，扩大readBuffer容量会导致缓存空间利用率不高，这对于内存资源是一直浪费。所以存在此类情况的消息不属于“一类消息”。 二类消息假设readBuffer的容量阈值依旧是1024，绝大部分消息长度都未超过该范围，但是偶尔有几个消息长度超过了1024，此为二类消息。二类消息的定义还存在一个限制条件，尽管消息长度超过了1024，但是不可超的太离谱。当我们认为一个消息因太长，导致无法完整的进行内存存储时，我们将其定义为“三类消息”。 三类消息此类消息是最难处理的一种，其特点就是消息体非常大，已经不适合进行内存存储了。例如文件上传类的Http消息，此时完整的消息可能小则几兆，大的则以G为单位。 提问：如果通信的所有消息都固定在1MB的大小，则此类消息算哪一种？ 在进阶篇中我们会介绍部分aio-pro的内容，它不仅包含了aio-core的所有功能，还提供了TLS/SSL通讯功能，并提供一些用于辅助编解码的工具类。（未来可能使之成为可以为smart-socket创造一些商业效益的模块） org.smartboot.socket aio-pro 1.3.7 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-05-27 14:34:42 "},"smart-socket/second/2-decoder.html":{"url":"smart-socket/second/2-decoder.html","title":"协议解码器","keywords":"","body":"协议解码器 如果等不及了就加QQ群：172299083 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-05-27 14:34:42 "},"smart-socket/second/3-type-one.html":{"url":"smart-socket/second/3-type-one.html","title":"一类消息","keywords":"","body":"一类消息 如果等不及了就加QQ群：172299083 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-05-27 14:34:42 "},"smart-socket/second/4-type-two.html":{"url":"smart-socket/second/4-type-two.html","title":"二类消息","keywords":"","body":"二类消息 重申一下“二类消息”的定义：长度超过了预先为Socket连接分配的读缓冲区大小的消息，即readBufferSize:512byte，接收到的实际MessageSize:600byte。针对此类消息，在解码时需要申请一个足够容量的临时缓冲区用于存放当前消息的字节数组。 然而smart-socket本身并不提供扩容读缓存的功能，是由于框架无法识别消息的有效性，一旦遭遇恶意攻击或者用户滥用可扩容的读缓冲区，会造成内存方面不可预知的异常情况。smart-socket在设计之初便非常重视服务的稳定性，对于用户技能水平的要求也会略高于某些同类通信框架，由此也导致smart-socket的使用体验稍显逊色。如果要在迎合用户的使用体验与服务可靠性之间做一个选择，smart-socket选择后者。至于如何处理好“二类消息”的编解码，我们也提供了一些解决方案以供参考。 以下案例会对实际场景中的协议进行简化处理，方便大家理解。首先，我们将读缓冲区设定为8字节。 定长协议 协议格式： 字段 含义 长度 length 消息头，其值表示消息体长度 4字节 data 消息体 length值 根据上述协议，假设客户端发送的消息为：9abcdefjhi，第一位消息头”9“为int类型，占用了4字节，后续的消息体“abcdefjhi”占用了9字节，所以服务端本次收到的消息长度为：13字节。由于读缓冲区的长度限制为8，则“5abcd”便填满了缓冲区，需要先将其读取完后再去读“efjhi”。编解码算法如下所示： public class FixedLengthProtocol implements Protocol { private static final int INT_BYTES = 4;//int类型的字节长度 @Override public String decode(ByteBuffer readBuffer, AioSession session, boolean eof) { if (session.getAttachment() == null && readBuffer.remaining() session) { byte[] bytes = msg.getBytes(); ByteBuffer buffer = ByteBuffer.allocate(INT_BYTES + bytes.length); buffer.putInt(bytes.length);//消息头 buffer.put(bytes);//消息体 buffer.flip(); return buffer; } } 特定结束符协议 协议格式： 字段 含义 长度 data 消息体 未知 endFlag 结束符 endFlag的字节长度 相较于定长协议，此类协议在解码结束之前都无法知晓消息的长度,直到读取到结束符标志，则此前所有已读的数据方可组成一个完整的消息或消息字段。例如按行发送的字符串数据：abc\\r\\n123\\r\\n，以\\r\\n作为结束符发送了两个消息：abc，123。 public class DelimiterProtocol implements Protocol { //结束符\\r\\n private static final byte[] DELIMITER_BYTES = new byte[]{'\\r', '\\n'}; @Override public String decode(ByteBuffer buffer, AioSession session, boolean eof) { DelimiterFrameDecoder delimiterFrameDecoder; if (session.getAttachment() == null) {//构造指定结束符的临时缓冲区 delimiterFrameDecoder = new DelimiterFrameDecoder(DELIMITER_BYTES, 64); session.setAttachment(delimiterFrameDecoder);//缓存解码器已应对半包情况 } else { delimiterFrameDecoder = (DelimiterFrameDecoder) session.getAttachment(); } //未解析到DELIMITER_BYTES则返回null if (!delimiterFrameDecoder.decode(buffer)) { return null; } //解码成功 ByteBuffer byteBuffer = delimiterFrameDecoder.getBuffer(); byte[] bytes = new byte[byteBuffer.remaining()]; byteBuffer.get(bytes); session.setAttachment(null);//释放临时缓冲区 return new String(bytes); } @Override public ByteBuffer encode(String msg, AioSession session) { byte[] bytes = msg.getBytes(); ByteBuffer buffer = ByteBuffer.allocate(bytes.length + DELIMITER_BYTES.length); buffer.put(bytes).put(DELIMITER_BYTES); buffer.flip(); return buffer; } } Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-05-27 14:34:42 "},"smart-socket/second/5-type-three.html":{"url":"smart-socket/second/5-type-three.html","title":"三类消息","keywords":"","body":"三类消息 如果等不及了就加QQ群：172299083 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-05-27 14:34:42 "},"donation.html":{"url":"donation.html","title":"关于捐赠","keywords":"","body":"关于捐赠 如果我们的项目对您的学习有所帮助，持续关注并积极反馈就是对我们最大的支持。 如果我们的项目解决了您工作上的难题，不妨请作者喝杯咖啡吧。 如果您的公司认可我们的开源项目，欢迎各种形式的支持。 捐赠清单 姓名 金额 时间 备注 noear 200 2018-06-12 萨博 50 2018 逼捐 龙马 50 2018 逼捐 贝尔 50 2018 逼捐 liweibo 99 2018 zhengwen6300 10 2018 刀锋剑雨 20 2018 小仙女 10 2017 捐赠入口 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-14 23:12:37 "}}