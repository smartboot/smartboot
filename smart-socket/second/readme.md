开篇概述
===

在基础篇中主要讲解的还是smart-socket的基本用法，可做为入门教程。然而实战过程中面临的情况会相对复杂一点，驾驭smart-socket更需要掌握一些技巧性的操作。在进阶篇中会介绍常见的几类场景，并提供相应的应对策略。

在正式讲解之前我们先来对常见的几种消息进行分类，方便大家理解消化。后续在工作终于遇到问题时可按照本文定义的类别寻找相应的解决方法。**注意，此处讲的是“消息”，并非协议**，可能有人疑惑这两者的区别。用面向对象的思想简单理解就是：协议等同于class，消息就是class实例化后的object。为了便于区分，我们将消息分类以下几种：
1. 一类消息    
  服务端与客户端之间通信的所有消息大小都是在一定范围内的，AIOSession的readBuffer容量完全可以承载至少一个消息（前提是readBuffer的容量本身就设置了一个“合理”的数值）。这个“合理”的定义是ReadBuffer容量尽可能的满足绝大部分消息长度，且数值不会超过一定阈值。假设我们暂定readBuffer的容量阈值为1024，那么以下几种消息则属于一类消息：
    - 所有消息长度都小于100，readBuffer设置容量为100
    - 消息长度范围[0,512)，readBuffer容量设置为512
    - 消息长度范围[0,1024),readBuffer容量设置为1024    
>**那如果消息长度范围为[0,2048)呢，我们是否可以通过将readBuffer容量设置为2048来满足我们的需求？**答案是否定的，如果绝大部分情况下消息大小在1024内，仅少量的消息大小在[1024,2048)区间内，扩大readBuffer容量会导致缓存空间利用率不高，这对于内存资源是一直浪费。所以存在此类情况的消息不属于“一类消息”。
2. 二类消息  
   假设readBuffer的容量阈值依旧是1024，绝大部分消息长度都未超过该范围，但是偶尔有几个消息长度超过了1024，此为二类消息。二类消息的定义还存在一个限制条件，尽管消息长度超过了1024，但是不可超的太离谱。当我们认为一个消息因太长，导致无法完整的进行内存存储时，我们将其定义为“三类消息”。
3. 三类消息    
此类消息是最难处理的一种，其特点就是消息体非常大，已经不适合进行内存存储了。例如文件上传类的Http消息，此时完整的消息可能小则几兆，大的则以G为单位。

>**提问：如果通信的所有消息都固定在1MB的大小，则此类消息算哪一种？**

--- 

在进阶篇中我们会介绍部分aio-pro的内容，它不仅包含了aio-core的所有功能，还提供了TLS/SSL通讯功能，并提供一些用于辅助编解码的工具类。（未来可能使之成为可以为smart-socket创造一些商业效益的模块）
```
 <dependency>
     <groupId>org.smartboot.socket</groupId>
     <artifactId>aio-pro</artifactId>
     <version>1.3.7</version>
 </dependency>
```

