## 前言
**百万级长连接**，这六个简单的字眼似乎拥有一种神奇的魅力，让人无法抗拒。在许多涉及通信相关的项目中，这类描述常常会出现在标题或介绍文案中，吸引着人们的目光。

倒不是说百万级长连接是个轻而易举的低端技术，也非大家为了噱头弄虚作假。
即便很多打着支持”百万级长连接“旗号的项目并未提供实测案例，但我依旧相信这件事的可行性。

从自身经验来看，实现百万级长连接并非难事。只要硬件资源足够，基本上所有通信框架都能做到，实现百万级长连接并不是什么值得炫耀的事。

其中更应当被关注到的是：**为了实现百万级长连接，需要消耗多少资源！**


相信大家或多或少看到过一些厂家在宣传自家产品百万级长连接的时候，都会配备十多台高规格的服务器来组建测试环境。对于个人开源项目的作者来说，这种豪华配置实在是遥不可及。

然而，smart-socket却仅需一台16G内存的PC机，就能同时支持百万级长连接的服务器和客户端进程（**注意：服务器和客户端都运行在同一台机器上，无需准备10多台压测机**）。这背后的秘诀便是我们采用的一项黑科技：低内存模式。而且，smart-socket是唯一一款有能力使用该技术的Java AIO通信框架。

接下来，我们将为大家深入解析低内存模式的原理，并阐述为何"smart-socket是唯一一款有能力使用该技术的Java AIO通信框架"。

## AIO 的内存模型

对AIO稍微有点了解的同学应该都知道，采用 AIO 实现的通信服务都必须调用AsynchronousSocketChannel的read或者write接口用于注册一个缓冲区buffer和回调任务，当底层完成IO操作后便会自动执行回调任务。


```
public final <A> void read(ByteBuffer dst,A attachment,CompletionHandler<Integer,? super A> handler)
{
    read(dst, 0L, TimeUnit.MILLISECONDS, attachment, handler);
}
```
**在这个过程中就带来了一个值得思考的问题：何时会完成IO操作是不确定的，而期间却要求缓冲区持续处于待命状态，这本质上是否是一种资源浪费的行为！**

假如每个客户端的读缓冲区容量1024字节，当需要建立百万级长连接的时候，仅仅是读缓冲区的内存需求就将近 1GB 了，服务端与客户端累加起来便差不多要 2GB，而现实场景中的缓冲区设置通常以（MB）为单位。

> 或许有同学认为，2GB 也不算多啊，按这个算法一台4GB内存的服务器就足以支撑百万长连接的。
（这里要注意一点，这个时候内存中多出来的不仅仅是100万个读缓冲区容量。而是维持1条通信连接涉及到的所有对象都翻了100万倍。）

回归正题，按照AIO的通信特性，其内存需求是随着连接数量的增长呈线性递增的。这些内存开销可以分为两部分：
1. 固定开销：Channel实例、IO线程池、标记位、处理器、各类辅助变量。
2. 弹性开销：读写缓冲区

其中**固定开销**有些是JVM层面使用的，有些是通信框架必要的组成部分，这一块的优化空间非常有限。所以 smart-socket 将优化方向瞄准了**弹性开销**这一部分，通过低内存模式实现少量且恒定的内存空间，便可支持百万级长连接。

## smart-socket的低内存原理
**所谓的低内存模式，便是当连接通道还不具备可读条件时，暂时回收为其分配的缓冲区空间，待其具备可读条件时再做内存分配。**

可是结合上文我们可以看到，当调用read方法时，读缓冲区已经托管给了JVM，它的默认策略便是持有该缓冲区空间直至读到数据为止，我们是无法对其干预的。

所以，smart-socket采用的方式便是重写 AIO 的底层实现。

`CompletionHandler<Integer,? super A> handler`的回调函数中会返回一个数值，当该值为`-1`时表示连接通道已关闭；当值大于0的时候表示本次缓冲区读到的字节数。smart-socket在此基础上扩展了两个状态位：
- -2：表示本次调用read方法传入的缓冲区中没有残留的半包数据，且当前通道不具备可读条件，smart-socket可以回收其内存空间供其他连接复用；底层继续监听连接通道的可读状态。
- -3：当连接通道具备可读数据时，通过返回状态值`-3`告知框架申请一块缓冲区空间，用于接收本次可读的数据。

![](https://files.mdnice.com/user/39742/810a5082-2d9b-47d6-a6c3-ab75911c9329.svg)

smart-socket便是通过这种提升缓冲区利用率的方式，实现了少量内存空间支撑海量连接的通信服务。

### 代码演示
1. 重写 Java AIO 实现的传输链路层，感知通道状态，并触发信号量。
   ![](https://files.mdnice.com/user/39742/b2f65a5a-11b6-43b2-b302-d01f102e422a.png)

2. 应用会话层接收信号量，并做出相应的缓冲区申请、释放处理。
   ![](https://files.mdnice.com/user/39742/e4b03bbf-b363-4c34-a0d7-9d2c72e5246f.png)

## 应用场景
低内存模式看似美好，实际上它的应用场景比较局限，所以smart-socket没有将其作为默认的通信调度策略。而是采用配置化的方式，由使用者根据自身实际情况，通过设置`AioQuickServer#setLowMemory`的布尔量决定是否启用。

启用低内存模式可以『**所面临的通信场景是否为海量连接，且非IO密集型**』为参考依据。

如果是IO密集型：说明无论连接量多少，每个连接都需要频繁使用读缓冲区，很大概率上难以满足内存回收条件。此时启用低内存反而增加了CPU开销。

倘若是非IO密集型，且连接量不多：此时低内存模式可作为可选项，毕竟少量的连接占用的缓冲区也有限，不至于造成内存资源紧张。

回归现实场景，同时满足海量连接且非IO密集型的条件，最具代表性的当属物联网场景。这类场景通常存在几万、几十万，甚至上百万的连接量，而每个连接的上报周期可能是秒级的，或者分钟级。此时启用低内存模式更能彰显技术的经济价值。
## 最后
在文章的最后，我们为开篇那句具有冲突性的观点作一下说明：**smart-socket是唯一一款有能力使用该技术的Java AIO通信框架**。

这并非smart-socket刻意拉踩同类产品，而是截止目前为止，市面上可用于生产环境的AIO框架本就非常稀少。而有能力发现Java原生AIO的设计缺陷，并对其作出改进的，仅此smart-socket一家。